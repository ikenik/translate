### FAQ по Sencha Architect 3.2
-------------------------------------------

**Именование itemId свойств - с префиксами:**

- cbx: Combobox
- btn: Button
- pnl: Panel
- cmp: Component
- cnt: Container
- grd: Grid
- fld: Field
- col: Column
- chb: CheckboxField
- txt: TextArea
- rb:  Radio
- tlb: Toolbar
- spr: Spacer
- drw: Ext.draw.Container
- mn:  Menu
- trp: Ext.tree.Panel


**Именование callback функций, при конфигурировании объектов в "Sencha Architect".**

**Описание на примере `ActionColumn`**

При конфигурировании `ActionColumn` требуется определить функции:

* `getClass` - получение cls иконки
* `handler` - обработчик нажатия на иконку действия
* `isDisabled` - активность действия для конкретной строки
* `getTip` - получить ToolTip (строка) иконки действия.

Т.к. это действие нужно добавить префикс `act`, но это не действие в плане `Ext.Action`, поэтому нужно подписать к префиксу `Col` что бы было понятно, что этот обработчик относится именно к действию колонке.

В итоге префикс будет `actCol`. Далее написать имя действия, например: `CaseSensitive` или `SortDirection` или `DeleteSelected`... Далее написать имя callback функции, которую определяем в конфигурации, но без префикса `get` или `is`.

**Привило**

**"Префикс объекта callback которого переопределяем 3-6 букв"** + **"Название действия"**  + **"Имя переопределяемой callback функции без `get` или `is`"**.

> `actCol` + `ActionName` + `column_callback_name`

**Примеры**

| callback ActionColumn | Пример именования             | Пример именования 2
|-----------------------|-------------------------------|--------------------------
| `getClass`            | `actColCaseSensitiveClass`    | `actColSortDirectionClass`
| `handler`             | `actColCaseSensitiveHandler`  | `actColSortDirectionHandler`
| `isDisabled`          | `actColCaseSensitiveDisabled` | `actColSortDirectionDisabled`
| `getTip`              | `actColCaseSensitiveTip`      | `actColSortDirectionTip`


**Если в header панели необходимо поместить элементы, то:**

- Свойство header: false
- Создаем toolbar со свойством docked: top

**Выравнивание кнопок по центру в ToolBar-e**

``` javascript
    {
        xtype: 'toolbar',
        "container|pack": "center",
    }
```

**Как создать `fbar: [x]` или `dockedItems['bottom',[x]]` - панель внизу с кнопками по центру**

``` javascript
{
     dockedItems: [{
              xtype: 'toolbar',
              dock: 'bottom',
              ui: 'footer',
              defaults: {minWidth: {@link #minButtonWidth}},
              items: [
                  { xtype: 'button', text: 'Применить' },
                  { xtype: 'button', text: 'Отмена', cls: ' link-button' }
              ]
          }]
}
```

у ToolBar-а выставить  "container|pack": "center"

**Формирование контейнера шагов мастера**

Основной контейнер с шагами:

``` javascript
    height: 600,
    width: 800,
    layout: 'card',
```

Контейнер конкретного шага:

``` javascript
Ext.form.Panel =  {
    xtype: 'form',
    border: false,
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
}
```

**Применение flex**

1. Для того, чтобы элемент при изменении размеров растягивался по вертикали/горизонтали выставляем ему
flex:1

2. Для пропорциональных размеров нескольких элементов необходимо выставить у каждого
flex: <необходимые пропорции>

### Правила верстки различных форм

-----------------------------------

**Общая вводная информация.**

В структуре различных форм компонентов есть всего три сущности:

**1.** **КОНТЕЙНЕР С РАМКОЙ** верхнего уровня , который содержит внутри себя различные *группы элементов*.
Им может быть:

- Панель [Panel](http://examples.sencha.com/extjs/5.0.0/examples/kitchensink/#basic-panels).
- Контейнер [Container](http://docs.sencha.com/extjs/5.1.0/api/Ext.container.Container.html) с рамкой. Или без рамки, если она формируется внешним ExtJS компонентом, например [Window](http://examples.sencha.com/extjs/5.0.0/examples/kitchensink/#basic-window)

К этой сущности применяются два отступа *16px*(сверху и снизу) и *28px*(по бокам).  Для того, чтобы они появились, **необходимо** прописать класс **.form-container**.

**2.** **ГРУППА ЭЛЕМЕНТОВ**. Содержит в себе различные элементы форм, которые располагаются друг под другом.
Группой может быть:

- [Fieldset](http://docs.sencha.com/extjs/5.1.0/api/Ext.form.FieldSet.html)
- [Container](http://docs.sencha.com/extjs/5.1.0/api/Ext.container.Container.html)

Между группами должен быть отступ *24px*.

**3.** **ЭЛЕМЕНТ ГРУППЫ**. Property Editor, обычный редактор или любая другая сущность, которая является вложенной в группу.
Между ними должен быть отступ **12px**

------------------

**Правило задания нужных отступов**

В большинстве случаев при создании форм нужно указать только один из двух классов: **form-layout** или **form-rows-layout** главному родительскому контейнеру формы.
1. **form-layout** делает первые по вложенности компоненты ExtJS **ГРУППАМИ**, остальные - **ЭЛЕМЕНТАМИ**.
2. **form-rows-layout** делает все компоненты **ЭЛЕМЕНТАМИ**.

И тогда все компоненты формы приобретут нужные горизонтальные и вертикальные отступы.

**Другие отступы**

- Для создания "подчиненного" контейтера с левым отступом от родительского укажите подчиненному класс **form-sub-container**

------------------

**Исключения из правил**

Очень редко требуется явно сделать **ГРУППУ** или **ЭЛЕМЕНТ**. Для этого какому-либо компоненту нужно указать классы:

- **.form-group** (группа)
- **.form-row** (элемент)

Также иногда из-за автоматического добавления вертикального отступа между соседними компонентами они могут стоять не на одной вертикали.
Как правило, такая ситуация случается при наличии разнородной структуры.
Обратите внимание на этом изображении на поле ввода, которое не находится на одной вертикали с другими.

![examples-7](imgs/examples/examples-7.png)

Чтобы удалить этот отступ, нужно компоненту, который справа от отступа (поле ввода), прописать класс **form-column-splitter-not-margin**.

К сожалению, не все подобные структуры можно предусмотреть изначально. Если вы заметите похожие нестыковки, создайте ISSUE в проекте [deductor-theme](http://redmine.basegroup.ru/projects/deductor-theme/issues)


-------------------

**Примеры:**

1. Стандартный .**form-layout** : **ГРУППЫ** на первом уровне вложенности (зеленым цветом) и далее **ЭЛЕМЕНТЫ** групп (красным 
цветом).

![examples-1](imgs/examples/examples-1.png)

То же самое на другом примере:

![examples-2](imgs/examples/examples-2.png)

2. Нестандартный **.form-rows-layout**, когда есть только **ЭЛЕМЕНТЫ**. Это форма в квантовании, которая встраивается в контейнер между строками таблицы. Поэтому ей необходим класс **.form-container**, чтобы ее элементы не "прилипали" к внешнему контейнеру.

![examples-3](imgs/examples/examples-3.png)

3. Случай, когда визард формируется из нескольких View в SenchaArchitect. Тогда для правильного расположения необходимо указывать классы .**form-layout** / **.form-rows-layout**
в каждом View. Один View визарда подключения

![examples-5](imgs/examples/examples-5.png)

и второй

![examples-4](imgs/examples/examples-4.png)

4. Пример применения класса **.form-container** для задания внутренних отступов формы от внешнего контейнера в обработчике конечные классы: 

![examples-6](imgs/examples/examples-6.png)

### Выравнивание ширины меток редакторов значений

---------------------

  Вы можете задать какому-либо контейнеру константу ширины меток его редакторов: `labelWidthValue`.  Возможные значения:

| Текстовое имя константы | Значение ширины метки
|-------------------------|-------------------------:
| `ExtraSmall`            |      70
| `Small`                 |      100
| `Medium`                |      150
| `Medium_1`              |      175
| `Big`                   |      200
| `Big_1`                 |      225
| `ExtraBig`              |      250
| `Large`                 |      300
| `ExtraLarge`            |      350
| `SuperLarge`            |      400


   **Функциональность:**

    - Ширина меток для редакторов делается одинаковой, чтобы сами редакторы выстраивались по одной вертикали
    - Учитывается вложенность редакторов в какие-либо контейнеры
    - Перекрытие одной константой другой. Пример: общая Large для родительского контейнера и еще одна Small в подчиненном
    - Перекрытие числовым значением labelWidth. Если внутри элемента с константой labelWidthValue есть     компонент с числовым
    значением labelWidth, которое задано в конфиге, то этому значению отдается приоритет над автоматическим выравниванием.

  Для того, чтобы добавить эту константу компоненту, в SenchaArchitect в поле "Filter Configs" введите labelWidthValue и нажмите "Add"

### Обратите внимание:

  На данный момент функционал задания отступов и ширины меток работает только на этапе конфигурирования, когда вся форма целиком
  задается в одном view конфиге ExtJS. Это значит, что при динамическом (в runtime, когда форма уже отрендерена) добавлении новых элементов,
  к ним не будут применены отступы и необходимая ширина меток. Чтобы этого избежать, можно:

    - Для задания нужных отступов при вставке нового компонента у него должен быть один из классов: .form-group / .form-row
    (для горизонтального отступа) и .form-column-splitter-margin для вертикального слева
    - Для задания ширины метки добавляемого редактора нужно помещать его в Ext.form.FieldContainer, который был добавлен в форму на
    этапе конфигурирования. Согласно документации ExtJS, все редакторы, помещенные в Ext.form.FieldContainer унаследуют от него ширину метки
    (которая будет назначена FieldContainer на этапе конфигурирования).
